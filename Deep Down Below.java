
import java.util.*;
import java.io.*;

import static java.lang.Math.min;
import static java.lang.Math.max;

public class Main {

    private static final long lif = (long) 1e9 + 7; //long infinity
    private static final int iif = 998244353; // int infinity!

    public static void main(String[] args) {
        try {
            FastReader in = new FastReader();
            FastWriter out = new FastWriter();

            Comparator<Pair> com = Comparator.comparingInt(i -> i.v1);

            int testcases = 1;

            testcases = in.nextInt();

            while (testcases-- > 0) {
                /*
                    Deep Down Below
                    we are given with the number of caves and the number of monsters in each cave!
                    there are 'x' caves, and in each cave we are given the number of monsters in that cave
                    and the armored value for each monster. The hero should have 1 more than the current monsters armored level!
                    So, we can defeat the monster!
                    We have to say what's the minimum value of the hero's power in order to defeat all the monster
                 */

                /*

                    The idea is to first we will find the max and min values for all the caves!

                    And we will use a standard Binary search in this range the condition is :

                    we will check the current hero's health with the current cave's highest rated monster!
                 */

                List<Pair> lis = new ArrayList<>();

                int caves = in.nextInt();

                int low = 0;

                int high = 0;

                for(int i = 0; i < caves; i++) {
                    int monsters = in.nextInt();
                    int leastHealthToEnterCave = 0;
                    for(int j = 0; j < monsters; j++) {
                        int currH = in.nextInt();
                        leastHealthToEnterCave = max(leastHealthToEnterCave,(currH-j)+1);
                    }
                    lis.add(new Pair(leastHealthToEnterCave,monsters));
                }

                lis.sort(com);

                low = lis.getFirst().v1;
                high = lis.getLast().v1;

                int minPossibleHealth = 0;

//                out.println(low+" "+high);

                while(low <= high) {
                    int currHealth = (low+high)>>1;
                    int cH = currHealth;
                    boolean canDefeat = true;
                    for(int i = 0; i < caves; i++) {
                        if(cH >= lis.get(i).v1) cH += lis.get(i).v2;
                        else {
                            canDefeat = false;
                            break;
                        }
                        if(canDefeat) {
                            minPossibleHealth = currHealth;
                            high = currHealth-1;
                        } else {
                            low = currHealth+1;
                        }
                    }
                }
//
                out.println(minPossibleHealth);
            }
            out.close();
        } catch (Exception e) {
            e.printStackTrace();
            return;
        }
    }

    //<--------------------------------------Fast reader----------------------------------------->
    static class FastReader {
        BufferedReader br;
        StringTokenizer st;

        public FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = "";
            try {
                str = br.readLine().trim();
            } catch (Exception e) {
                e.printStackTrace();
            }
            return str;
        }
    }

//<---------------------------------------Fast writer--------------------------------------------->

    static class FastWriter {
        private final BufferedWriter bw;

        public FastWriter() {
            this.bw = new BufferedWriter(new OutputStreamWriter(System.out));
        }

        public void print(Object object) throws IOException {
            bw.append("" + object);
        }

        public void println() throws IOException {
            bw.append("\n");
        }

        public void println(Object object) throws IOException {
            print(object);
            bw.append("\n");
        }

        public void close() throws IOException {
            bw.close();
        }
    }

// <-------------------------------------------------Some helper methods---------------------------------------->

    public static List<Integer> reversed(List<Integer> lis) {
        List<Integer> ans = new ArrayList<>();
        for(int i = lis.size()-1; i >= 0; i--) {
            ans.add(lis.get(i));
        }
        return ans;
    }

    private static int update(int ans, int i) {
        return (int)((ans*1L*i)%iif);
    }

    private static void getFactors(int num, Map<Integer, Integer> map) {

        for(int i = 2; i <= (int) Math.sqrt(num); i++) {
            while(num%i == 0) {
                map.put(i,map.getOrDefault(i,0)+1);
                num /= i;
            }
        }
        if(num > 1) map.put(num,map.getOrDefault(num,0)+1);
    }

    public static void print(boolean cond) {
        System.out.println(cond ? "YES" : "NO");
    }

    public static long fastPow(long b, long e) {
        long res = 1;
        while (e > 0) {
            if (odd(e)) res = (res * b) % lif;
            b = (b * b) % lif;
            e = e >> 1;
        }
        return res;
    }

    public static int charToInt(char c) {
        return (c - '0');
    }

    public static char intToChar(int n) {
        return (char) (n + 48);
    }

    public static int[] sieve(int upto) {
        int[] primes = new int[upto + 1];
        Arrays.fill(primes, 1);
        for (int i = 2; i * i <= upto; i++) {
            if (primes[i] == 1)
                for (int j = i * i; j <= upto; j += i) {
                    primes[j] = 0;
                }
        }
        return primes;
    }

    private static long gcd(long a, long b) {
        if (b != 0) return gcd(b, (a % b));
        return a;
    }

    private static int gcd(int a, int b) {
        if (b != 0) return gcd(b, (a % b));
        return a;
    }

    private static long sumN(long siz) {
        return (siz * (siz + 1)) >> 1;
    }

    private static boolean odd(long siz) {
        return (siz & 1) == 1;
    }

    private static boolean powOf2(long siz) {
        return (siz & (siz - 1)) == 0;
    }

    private static List<Integer> primeFactors(int siz) {

        List<Integer> sizs = new ArrayList<>();
        int[] p;
        p = sieve(siz);
        for (int i = 2; i <= siz; i++) {
            while (siz % i == 0 && p[i] == 1) {
                sizs.add(i);
                siz /= i;
            }
        }
        return sizs;
    }
}

class Pair2 {
    long v1;
    long v2;

    public Pair2(long v1, long v2) {
        this.v1 = v1;
        this.v2 = v2;
    }
}
class Pair {
    int v1,v2;
    public Pair(int v,int w) {v1 = v; v2 = w;}
}